-- in.cue --
@experiment(try)

// else cannot access for variable
forVarInElse: {
	for i in [1,2,3] { "\(i)": i } fallback { bad: i }
}

// else cannot access let variable from comprehension
letVarInElse: {
	for x in [1,2,3] let y = x*2 { "\(x)": y } fallback { bad: y }
}

// Note: Multiple clause cases with else are caught at parse time, not compile time:
// - if + let with else: if cond let x = val { ... } else { ... }
// - Two if clauses with else: if cond1 if cond2 { x } else { y }
// - Chained try with else: try x = a? try y = b? { ... } else { ... }
// - Mixed if/try with else: if cond try { x } else { y }
// - if + for with else: if cond for x in [] { x } else { y }
// These all produce parser error: "else clause only allowed with single 'if' or 'try' clause"
// or "use 'fallback' with 'for' clauses"
-- out/eval/stats --
Leaks:  0
Freed:  2
Reused: 2
Allocs: 0
Retain: 0

Unifications: 2
Conjuncts:    2
Disjuncts:    2

NumCloseIDs: 0
-- out/evalalpha --
forVarInElse.bad: reference "i" not found:
    ./in.cue:5:49
letVarInElse.bad: reference "y" not found:
    ./in.cue:10:61
-- out/compile --
forVarInElse.bad: reference "i" not found:
    ./in.cue:5:49
letVarInElse.bad: reference "y" not found:
    ./in.cue:10:61
--- in.cue
{
  forVarInElse: {
    for _, i in [
      1,
      2,
      3,
    ] {
      "\(〈1;i〉)": 〈1;i〉
    } else {
      bad: _|_(reference "i" not found)
    }
  }
  letVarInElse: {
    for _, x in [
      1,
      2,
      3,
    ] let y = (〈0;x〉 * 2) {
      "\(〈2;x〉)": 〈1;y〉
    } else {
      bad: _|_(reference "y" not found)
    }
  }
}
