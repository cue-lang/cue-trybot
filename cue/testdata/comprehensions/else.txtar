-- in.cue --
@experiment(try)

// if-else: condition true - no else
ifTrue: {
	if true { a: 1 } else { b: 2 }
}

// if-else: condition false - else yields
ifFalse: {
	if false { a: 1 } else { b: 2 }
}

// for-else: non-empty source - no else
forNonEmpty: {
	for x in [1, 2] { "\(x)": x } fallback { empty: true }
}

// for-else: empty source - else yields
forEmpty: {
	for x in [] { "\(x)": x } fallback { empty: true }
}

// for-else with filter: filter removes all - else yields
forFilteredAll: {
	for x in [1, 2, 3] if x > 10 { "\(x)": x } fallback { empty: true }
}

// for-else with filter: filter keeps some - no else
forFilteredSome: {
	for x in [1, 2, 3] if x > 1 { "\(x)": x } fallback { empty: true }
}

// if-for-fallback: if true, for empty - fallback yields
ifTrueForEmpty: {
	if true for x in [] { "\(x)": x } fallback { empty: true }
}

// if-for-fallback: if false, for non-empty - fallback yields (if blocks iteration)
ifFalseForNonEmpty: {
	if false for x in [1, 2] { "\(x)": x } fallback { empty: true }
}

// if-for-fallback: if true, for non-empty - no fallback
ifTrueForNonEmpty: {
	if true for x in [1, 2] { "\(x)": x } fallback { empty: true }
}

// list if-else: true
listIfTrue: [
	if true { 1 } else { 2 }
]

// list if-else: false
listIfFalse: [
	if false { 1 } else { 2 }
]

// list for-else: empty
listForEmpty: [
	for x in [] { x } fallback { 0 }
]

// list for-else: non-empty
listForNonEmpty: [
	for x in [1, 2] { x * 2 } fallback { 0 }
]

// else with multiple fields
elseMultipleFields: {
	if false { a: 1 } else { b: 2, c: 3 }
}

// else embeds into existing struct
elseEmbeds: {
	existing: 1
	if false { added: 2 } else { fallback: 3 }
}

// fallback with outer scope access
outerScope: {
	let threshold = 10
	for x in [] { x } fallback { fallbackField: threshold }
}

// if-else: nested body fields - else yields once
ifNestedBody: {
	if false { a: b: 1 } else { c: 2 }
}

// if-else: nested else fields
ifNestedElse: {
	if false { a: 1 } else { b: c: 2 }
}

// if-else: nested fields in both
ifNestedBoth: {
	if false { a: b: 1 } else { c: d: 2 }
}

// if-else: deeply nested fields
ifDeeplyNested: {
	if false { a: b: c: 1 } else { a: b: c: 2 }
}

// for-fallback: nested body fields, empty source
forNestedEmpty: {
	for x in [] { a: b: (x): x } fallback { a: b: none: true }
}

// for-fallback: nested body fields, non-empty source - no fallback
forNestedNonEmpty: {
	for x in [1] { a: b: "\(x)": x } fallback { a: b: none: true }
}

// nested comprehensions - outer fallback triggers
nestedOuterFallback: {
	for x in [] { for y in [1] { y } fallback { inner: true } } fallback { outer: true }
}

// nested comprehensions - inner fallback triggers
nestedInnerFallback: {
	for x in [1] { for y in [] { y } fallback { inner: true } } fallback { outer: true }
}
-- out/eval/stats --
Leaks:  0
Freed:  69
Reused: 60
Allocs: 9
Retain: 0

Unifications: 69
Conjuncts:    90
Disjuncts:    69

NumCloseIDs: 2
-- out/evalalpha --
(struct){
  ifTrue: (struct){
    a: (int){ 1 }
  }
  ifFalse: (struct){
    b: (int){ 2 }
  }
  forNonEmpty: (struct){
    "1": (int){ 1 }
    "2": (int){ 2 }
  }
  forEmpty: (struct){
    empty: (bool){ true }
  }
  forFilteredAll: (struct){
    empty: (bool){ true }
  }
  forFilteredSome: (struct){
    "2": (int){ 2 }
    "3": (int){ 3 }
  }
  ifTrueForEmpty: (struct){
    empty: (bool){ true }
  }
  ifFalseForNonEmpty: (struct){
    empty: (bool){ true }
  }
  ifTrueForNonEmpty: (struct){
    "1": (int){ 1 }
    "2": (int){ 2 }
  }
  listIfTrue: (#list){
    0: (int){ 1 }
  }
  listIfFalse: (#list){
    0: (int){ 2 }
  }
  listForEmpty: (#list){
    0: (int){ 0 }
  }
  listForNonEmpty: (#list){
    0: (int){ 2 }
    1: (int){ 4 }
  }
  elseMultipleFields: (struct){
    b: (int){ 2 }
    c: (int){ 3 }
  }
  elseEmbeds: (struct){
    existing: (int){ 1 }
    fallback: (int){ 3 }
  }
  outerScope: (struct){
    let threshold#1 = (int){ 10 }
    fallbackField: (int){ 10 }
  }
  ifNestedBody: (struct){
    c: (int){ 2 }
  }
  ifNestedElse: (struct){
    b: (struct){
      c: (int){ 2 }
    }
  }
  ifNestedBoth: (struct){
    c: (struct){
      d: (int){ 2 }
    }
  }
  ifDeeplyNested: (struct){
    a: (struct){
      b: (struct){
        c: (int){ 2 }
      }
    }
  }
  forNestedEmpty: (struct){
    a: (struct){
      b: (struct){
        none: (bool){ true }
      }
    }
  }
  forNestedNonEmpty: (struct){
    a: (struct){
      b: (struct){
        "1": (int){ 1 }
      }
    }
  }
  nestedOuterFallback: (struct){
    outer: (bool){ true }
  }
  nestedInnerFallback: (struct){
    inner: (bool){ true }
  }
}
-- out/compile --
--- in.cue
{
  ifTrue: {
    if true {
      a: 1
    } else {
      b: 2
    }
  }
  ifFalse: {
    if false {
      a: 1
    } else {
      b: 2
    }
  }
  forNonEmpty: {
    for _, x in [
      1,
      2,
    ] {
      "\(〈1;x〉)": 〈1;x〉
    } else {
      empty: true
    }
  }
  forEmpty: {
    for _, x in [] {
      "\(〈1;x〉)": 〈1;x〉
    } else {
      empty: true
    }
  }
  forFilteredAll: {
    for _, x in [
      1,
      2,
      3,
    ] if (〈0;x〉 > 10) {
      "\(〈1;x〉)": 〈1;x〉
    } else {
      empty: true
    }
  }
  forFilteredSome: {
    for _, x in [
      1,
      2,
      3,
    ] if (〈0;x〉 > 1) {
      "\(〈1;x〉)": 〈1;x〉
    } else {
      empty: true
    }
  }
  ifTrueForEmpty: {
    if true for _, x in [] {
      "\(〈1;x〉)": 〈1;x〉
    } else {
      empty: true
    }
  }
  ifFalseForNonEmpty: {
    if false for _, x in [
      1,
      2,
    ] {
      "\(〈1;x〉)": 〈1;x〉
    } else {
      empty: true
    }
  }
  ifTrueForNonEmpty: {
    if true for _, x in [
      1,
      2,
    ] {
      "\(〈1;x〉)": 〈1;x〉
    } else {
      empty: true
    }
  }
  listIfTrue: [
    if true {
      1
    } else {
      2
    },
  ]
  listIfFalse: [
    if false {
      1
    } else {
      2
    },
  ]
  listForEmpty: [
    for _, x in [] {
      〈1;x〉
    } else {
      0
    },
  ]
  listForNonEmpty: [
    for _, x in [
      1,
      2,
    ] {
      (〈1;x〉 * 2)
    } else {
      0
    },
  ]
  elseMultipleFields: {
    if false {
      a: 1
    } else {
      b: 2
      c: 3
    }
  }
  elseEmbeds: {
    existing: 1
    if false {
      added: 2
    } else {
      fallback: 3
    }
  }
  outerScope: {
    let threshold#1 = 10
    for _, x in [] {
      〈1;x〉
    } else {
      fallbackField: 〈1;let threshold#1〉
    }
  }
  ifNestedBody: {
    if false {
      a: {
        b: 1
      }
    } else {
      c: 2
    }
  }
  ifNestedElse: {
    if false {
      a: 1
    } else {
      b: {
        c: 2
      }
    }
  }
  ifNestedBoth: {
    if false {
      a: {
        b: 1
      }
    } else {
      c: {
        d: 2
      }
    }
  }
  ifDeeplyNested: {
    if false {
      a: {
        b: {
          c: 1
        }
      }
    } else {
      a: {
        b: {
          c: 2
        }
      }
    }
  }
  forNestedEmpty: {
    for _, x in [] {
      a: {
        b: {
          〈3;x〉: 〈3;x〉
        }
      }
    } else {
      a: {
        b: {
          none: true
        }
      }
    }
  }
  forNestedNonEmpty: {
    for _, x in [
      1,
    ] {
      a: {
        b: {
          "\(〈3;x〉)": 〈3;x〉
        }
      }
    } else {
      a: {
        b: {
          none: true
        }
      }
    }
  }
  nestedOuterFallback: {
    for _, x in [] {
      for _, y in [
        1,
      ] {
        〈1;y〉
      } else {
        inner: true
      }
    } else {
      outer: true
    }
  }
  nestedInnerFallback: {
    for _, x in [
      1,
    ] {
      for _, y in [] {
        〈1;y〉
      } else {
        inner: true
      }
    } else {
      outer: true
    }
  }
}
